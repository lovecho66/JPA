# 3장 영속성관리

## 서론
  - JPA가 제공하는 기능은 크게 엔티티와 테이블을 매핑하는 [실제부분]과 매핑한 앤티티를 [실제사용하는 부분]으로 나눌 수 있다.
  - 엔티티 매니저는 엔티티와 관련된 모든 일을 처리한다.
  - 엔티티를 저장하는 가상의 데이터베이스로 생각하면된다.

## 3.1 엔티티 매니저 팩토리와 엔티티 매니저
```java
  //공장 만들기,비용이 아주 많이 든다.
  EntityManagerFactory emf = Persistence.createEntityManagerFactory(njpabook”);
```
- META-INF /persistence.xml에 있는 정보를 바탕으로 EntityManagerFactory를 생성한다.
- 데이터베이스를 하나만 사용하는 애플리케이션은 일반적으로 EntityManager Factory를 하나만 생성한다.
- 엔티티메니저팩토리를 만들 때 비용이 많이 든다.

```java
  //공장에서 엔티티 매니저 생성, 비용이 거의 안 든 다 .
  EntityManager em = emf.createEnt tyManager ;
```
- 엔티티 매니저 팩토리는 생성시 비용이 많이 들기 때문에 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다.(공장은 공유하자~)
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.
  
![ConnectionMaker](./images/3.1.PNG)

- 엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.
- 트랜잭션을 시작할 때 커넥션을 획득한다.
- 하이버네이트를 포함한 JPA 구현체들은 EntityManagerFactory를 생성할 때 커넥션풀도 만든다.

## 3.2 영속성 컨텍스트란?
- 영속성 컨텍스트는 JPA가 작업하는 공간으로 엔티티를 영구 저장하는 환경이다.
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 메니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리할 수 있다.

## 3.3 엔티티의 생명주기
![ConnectionMaker](./images/3.2.PNG)

- 엔티에는 4가지 상태가 존재한다.
  - 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 영속 : 영속성 컨텍스트에 저장된 상태
  - 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 삭제  : 삭제된 상태
    
### 비영속
![ConnectionMaker](./images/3.3.PNG)
 - 엔티티 객체를 생성했으면 영속성 컨텍스트나 데이터베이스에 전혀 관련이 없는 순수한 객체 상태다.
 - 컨텍스트와 연관이 전혀 없는 상태를 비영속 상태라고 한다.
### 영속
![ConnectionMaker](./images/3.4.PNG)
- 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라고 한다.
- persist,find,JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태이다. 
### 준영속
- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
- 특정 엔티티를 준영속 상태로 만들려면 em.detach()를 호출하면 된다.
- em.close()를 호출해서 영속성 컨텍스트를 닫으면 준영속 상태가된다.
- em.clear()를 호출해서 영속성 컨텍스트를 초기화하면 준영속 상태가 된다.
### 삭제
```java
//객체를 삭제한 상태(삭제)
em.remove(member);
```
- 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

### 3.4 영속성 컨텍스트의 특징
 ## 서론
 - 영속성 컨텍스트의 특징
  - 영속성 컨텍스트와 식별자 값
     - 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
     - 영속 상태 식별자 값이 반드시 있어야 한다.
     - 식별자 값이 없으면 예외가 발생한다.
       
  - 영속성 컨텍스트와 데이터베이스 저장
     - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시라 한다.

  - 영속성 컨텍스트가 엔티티를 관리하면 좋은 점
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩
## 3.4.1 엔티티 조회 
  - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라고 한다.
  - 영속 상태의 엔티티는 모두 이곳에 저장된다.
  - 영속성 컨텍스트 내부에 Map이 하나 있는데 키는 @Id로 매핑한 [식별자]고 값은 [인스턴스]다.
  
  ```java
  // 엔티티를 생성한 상태 (비영속)
  Member member = new Member();
  member.setld("member1");
  member. setUsername ("회원1") ;
  / / 엔티티를 영속
  em.persist(member);
  ```
![ConnectionMaker](./images/3.5.PNG)

- 1차 캐시의 키는 식별자 값이다.
- 식별자 값은 데이터베이스 기본 키와 매핑되어있다.
- 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스의 기본키 값이다.

```java
Member member = em.find (Member. class, "memberl") ; 
```
- em.find()를 호출하면 먼저 1차 캐시에서 엔티티를 찾고 만약 찾는 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회한다.

### 1차 캐시에서 조회
![ConnectionMaker](./images/3.6.PNG)

- 1차 캐시에서 식별자 값으로 엔티티를 찾는다.
- 찾는 엔티티가 있으면 데이터베이스를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다.
- persist()로 저장시켰을 때도 1차 캐시에 저장한 것으로 이후 find()를 해서 값을 가져올 때도 1차 캐시에서 값을 가져올 수 있다.

### 데이터베이스에서 조회
![ConnectionMaker](./images/3.7.PNG)
- 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다.
- 1차 캐시에 저장한 후 영속 상태의 엔티티를 반환한다.
- 메모리에 있는 1차 캐시에서 바로 불러오면 성능상의 이점을 누릴 수 있다.

### 영속 엔티티의 동일성 보장
```java
Member a = em.find(Member.class, "memberl”) ;
Member b = em.find (Member. class, "member1") ;
System.out .println (a == b) ; / / 동일성 비교
```
 - 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.
 - 둘은 같은 인스턴스고 결과는 당연히 참이다.
 - 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.

> 동일성과 동등성
> 동일성은 실제 인스턴스가 같다. == 비교값이 같다.
> 동등성은 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. equals() 비교값이 같다.

## 3.4.2 엔티티 등록
```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 한다.
transaction.begin() ; // [트랜잭션] 시작

em.persist(memberA);
em.persist(memberB);

//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.
//커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
transaction. commit () ; // [트랜잭션] 커밋
```
![ConnectionMaker](./images/3.8.PNG)

- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부쿼리 저장소에 INSERT을 차곡차곡 모아둔다.
- 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다.
- 이런 기능을 쓰기 지연이라고 한다.
- 그림을 보면 영속성 컨텍스트는 1차 캐시에 회원 엔티티를 저장하면서 동시에 회원 엔티티 정보로 등록 쿼리를 만든다.
- 만들어진 등록 쿼리를 쓰기 지연 SQL 저장소에 보관한다.
![ConnectionMaker](./images/3.9.PNG)
- commit을 하기 전까지 1차 캐시와 쓰기지연 SQL 저장소에 쿼리가 쌓인다.
![ConnectionMaker](./images/3.10.PNG)
- 트랜잭션을 커밋하면 엔티티 매니저는 플러시해서 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다.
- 영속성 컨텍스트의 변경 내용이 데이터베이스에 동기화한 후에 실제 데이터베이스 트랜잭션을 커밋한다.
> 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다.

### 트랜잭션을 지원하는 쓰기 지연이 가능한 이유
- 메모리에 모아두고 트랜잭션을 커밋할 때 모아둔 등록 쿼리를 데이터베이스에 보낸 후에 커밋한다.
- 어떻게든 커밋 직전에만 데이터베이스에 SQL 을 전달하면 된다.
- 트랜잭션을 지원하는 쓰기 지연이 가능한 이유다.
- 이 기능을 잘 활용하면 모아둔 등록 쿼리를 데이터베이스에 한번에 전달해서 성능을 최적화ㅏ할 수 있다.

## 3.4.3 엔티티 수정
