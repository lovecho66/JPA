# 16장_트랜잭션과 락,2차 캐시

<b>✨설명 전 Point 잡고 가기✨</b> 
- JPA가 제공하는 __트랜잭션과 락 기능__ 을 다룬다.
- JPA가 제공하는 __애플리케이션 범위의 캐시(2차캐시)__ 를 다룬다.

## 16.1 트랜잭션과 락

### 16.1.1 트랜잭션과 격리 수준

- 트랜잭션은 ACID라는 원자성,일관성,격리성,지속성을 보장해야한다.
  - 원자성 : 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 __모두__ 성공하든가 __모두__ 실패해야 한다.
  - 일관성 : 모든 트랜잭션은 __일관성 있는 데이터베이스 상태__ 를 유지해야 한다.
  - 격리성 : 동시에 실행되는 트랜잭션들이 __서로에게 영향을 미치지 않도록__ 격리한다.
    (격리성은 동시성과 관련된 성능 이슈로 인해 격리 수준을 선택할 수 있다.)
  - 지속성 : 트랜잭션을 __성공적__ 으로 끝내면 그 결과가 항상 기록되어야 한다.
 
- 트랜잭션은 원자성,일관성,격리성,지속성을 보장해야한다고 했는데 그중 문제가 되는게 __격리성__ 이다.
- 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 __차례대로 실행__ 해야한다.
- 근데 이렇게 하면 __동시성 처리 성능이 매우 나빠진다.__

- 트랜잭션 격리 수준 4가지
  ■ READ UNCOMMITED(커밋되지 않은 읽기)
  ■ READ COMMITTED(커밋된 읽기)
  ■ REPEATABLE READ(반복 가능한읽기 )
  ■ SERIALIZABLE (직렬화가능)

- 트랜잭션 격리 수준에 따른 문제점들도 있다.

![ConnectionMaker](./images/16.1_1.PNG)   

- DIRTY READ
- NON-REPEATABLE READ (반복 불 가 능 한 읽기 )
- PHANTOM READ
3가지 문제점들이 있다.

- 격리 수준에 따라 나타나는 문제점을 보자.
  - READ UNCOMMITTED：커밋하지 않은 데이터를 읽을 수 있다. DIRTY READ를 허용한다.
    * 트랜잭션 2가 DIRTY READ한 데이터를 사용하는데 트랜잭션 1을 롤백하면 데이터 정합성에 심각한 문제가 발생할 수 있다
    * DIRTY READ 예시 : 트랜잭션1이 데이터를 수정하고 있는데 커밋하지 않아도 트랜잭션 2가 수정 중인 데이터를 조회할 수 있다
  - READ COMMITTED : 격리 수준이 가장 낮음, serializable의 격리 수준이 가장 높다. 대신 NON-REPEATABLE READ는 발생할 수 있다.
    * 반복해서 같은 데이터를 읽을 수 없는 상태가 될 수 있다. 
    * NON-REPEATABLE READ 예시 : 트랜잭션 1 이 회원 A를 조회 중인데 갑자기 트랜잭션 2가 회원 A를 수정하고 커밋하면 트랜잭션 1 이 다시 회원 A를 조회했을 때 수정된 데이터가 조회된다.
    * . DIRTY READ는 허용하지 않지만, NON-REPEATABLE READ는 허용하는 격리 수준을 READ COMMITTED라 한다.
  -  REPEATABLE READ: 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. NON-REPEATABLE READ 는 허용하지 않지만 PHANTOM READ는 발생할 수 있다.
    * 반복 조회 시 결과 집합이 달라질 수 있다. 
    * PHANTOM READ 예시 : 트랜잭션1이 10살 이하의 회원을 조회했는데 트랜잭션 2가 5살 회원을 추가하고 커밋하면 트랜잭션1이 다시 1〇 살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다.
  - SERIALIZABLE : 가장 엄격한 트랜잭션 격리 수준이다. 여기서는 PHANTOM READ가 발생하지 않는다.
    * 동시성 처리 성능이 급격히 떨어질 수 있다.
   
- 애플리케이션 대부분은 동시성 처리가 중요하므로 데이터베이스들은 보통 READ COMMITTED 격리 수준을 기본으로 사용한다. 
- 일부 중요한 비즈니스 로직에 더 높은 격리 수준이 필요하면 데이터베이스 트랜잭션이 제공하는 잠금 기능을 사용하면 된다.
  
## 16.2 2차 캐시
---------------------------------------
## 5.1 단방향 연관관계
### 5.1.1 순수한 객체 연관관계
```java
public class Member {
  private String id; 
  private String username;
  private Team team; //팀의 참조 보관

  public void setTeam(Team team) { 
    this,team = team;
  }
//Getter, Setter ...
```
1. Member 엔티티가 Team 엔티티를 참조할 수 있게 설정했다.
![ConnectionMaker](./images/16.1_1.PNG)   
2.객체는 참조를 사용해서 연관관계를 탐색할 수 있다.(객체 그래프 탐색)
### 5.1.2 테이블 연관관계
