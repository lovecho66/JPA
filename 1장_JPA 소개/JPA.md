# 1장 JPA 소개

## 1.1 SQL을 직접 다룰 때 발생하는 문제점은 뭘까?

### 서론
- 자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.
- 데이터베이스에 데이터를 관리하려면 SQL을 사용해야 한다.
- JDBC API를 사용해서 SQL을 데이터베이스에 전달한다.

### 1.1.1 반복,반복,반복,반복 또 반복~♫
- 객체를 바로 DB에 넣고 조회할 수 있으면 좋겠지만 데이터베이스와 객체 구조는 너무 다르다.
- 그럼에도 우리는 객체를 DB에 넣어주기 위해 개발자가 SQL과 JDBC API를 사용해서 변환작업을 해줘야 한다.
- 어떠한 기능을 구현하더라도 변환작업 [SQL 작성, JDBC API 사용, 매핑]은 똑같이 작성해줘야한다.
- 데이터 접근 계층(DAO)에서 반복되는 변환작업을 지루하게 반복~ 반복~ 한다.

### 1.1.2 SQL에 의존적인 개발
- 필드를 추가해달라는 요구사항을 적용하려면 등록코드,수정코드,연관객체 작업할 때 SQL,JDBC API 수정해야하고
  조회코드는 매핑작업도 추가해서 확인해줘야 한다.
- 필드 하나 추가해달라는 요청사항으로 등록,수정,조회,연관 부분에서 하나씩 다 신경써주고 작업해야한다.
- 결국 SQL에 모든 것을 의존하는 상황에서는 엔티티를 신뢰하고 사용할 수 없다.
- 엔티티와 SQL은 아주 강한 의존관계를 가지고 있어 DAO에서 CRUD 코드와 SQL을 변경해야한다.
- 진정한 의미의 계층 분할도 아니고 엔티티를 신뢰할 수 없고 SQL에 의존적인 개발을 피하기 어렵다.
> 엔티티 : 비즈니스 요구사항을 모델링한 객체 (ex> Member, Team)

### 1.1.3 JPA와 문제 해결
- JPA를 사용하게 되면 객체를 데이터베이스에 저장하고 관리할 때 SQL을 작성할 필요가 없다.
- JPA가 제공하는 API를 사용하면 된다.
- JPA가 객체와 매핑정보를 보고 적절한 SQL 생성하고 데이터베이스에 전달한다.
- 조회같이 반환결과가 있다면 객체를 생성해서 반환한다.
- 수정같은 경우엔 별도 수정 메소드 없이 객체를 조회해서 값을 변경만 하면된다.
> 매핑정보는 어떤 객체를 어떤 테이블에 관리할지 정의한 정보

## 1.2 패러다임의 불일치 

### 서론
- 비즈니스 요구사항을 정의한 도메인 모델을 객체로 모델링하면 객체지향 언어가 가진 장점을 활용할 수 있다.
- 복잡한 애플리케이션은 대부분 객체지향 언어로 개발한다.
- 부모 객체를 상속받았거나 다른 객체를 참조하고 있다면 객체지향 언어로는 객체의 상태를 저장하기 쉽지 않다.
- 단순히 회원 객체만 저장하면 참조하는 팀 객체를 잃어버리는 경우가 생기는 것처럼 쉽지않다.
- 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고 직합적인 사고를 요구하기 때문에 객체를 저장시키기 알맞다.
- 그러나 관계형 데이터베이스에 바로 객체를 저장하기에 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다.
- 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.
- 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제를 해결하는데 너무 많은 시간과 코드를 소비하고 있다.

### 1.2.1 상속
- 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.
- 어떤 자식 테이블과 관계가 있는지 정의하는 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 가장 유사항 형태로 테이블 설계가 된다.
- 객체를 저장하게 되면 개발자가 직접 객체를 분해해서 두 SQL을 만들고 자식 타입에 따라서 슈퍼타입키도 변경해줘야한다.
  
#### JPA와 상속
- JPA를 사용하면 상속과 관련된 패러다임의 불일치를 해결하려고 소모하는 비용이 줄어든다.
- persist() 메소드를 사용하면 JPA가 INSERT SQL을 자동으로 생성해서 저장한다.
- find() 메소드를 사용하면 JPA가 연관된 테이블을 조인해서 조회한다.

## 1.2.2 연관관계
- 객체는 참조를 사용해서 다른 객체에 접근하여 연관된 객체를 조회한다.(객체는 참조가 있는 방향으로만 조회가능)
- 반면, 테이블은 외래키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.
- 참조를 사용하는 객체와 외래키를 사용하는 관계형 데이터베이스 사이의 패러다임 불일치의 문제가 크다.

### 객체를 테이블에 맞춰서 모델링
- 관계형 데이터베이스는 조인이라는 기능이 있으므로 외래키의 값을 그대로 보관해도 된다. 
- 객체는 연관된 객체의 참조를 보관해야 참조를 통해 연관된 객체를 찾을 수 있다.
- 외래키까지 관계형 데이터베이스가 사용하는 방식에 맞추면 참조를 통해서 조회할 수 없다.
- 좋은 객체 모델링은 기대하기 어렵고 결국 객체지향의 특징을 잃어버린다.

### 객체지향 모델링
- 객체는 참조를 통해서 관계를 맺는다.
- 객체의 필드를 보면 외래키의 값을 그대로 보관하는 것이 아니라 연관된 참조를 보관한다. (member.getTeam())
- 객체는 필드로 연관관계를 맺고 테이블은 외래키로 연관관계를 맺는다.
- 객체 모델은 외래키가 필요없고 참조만 있으면 되고테이블은 참조가 필요없고 외래키만 있으면 된다.
- 개발자가 중간에서 변환 역할을 해야한다.
- 저장하려면 외래키 값으로 변환해서 필드에 저장하고 조회시에 외래키 값을 객체의 참조로 변환해서 객체에 보관한다.

### JPA와 연관관계
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다.
- 개발자는 객체간의 관계만 설정하고 저장하면 JPA가 참조를 외래키로 변환해서 적절한 SQL문을 데이터베이스에 전달한다.

```java
/*저장*/
member.setTeam(team); //회원과 팀 연관관계 설정
jpa.persist(member);  //회원과 연관관계 함께 저장
```

- 객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPA가 한다.
```java
/*조회*/
Member member =jpa.find(Member.class,merberId); 
Team team = member.getTeam(); 
```

### 1.2.3 객체 그래프 탐색
- 객체가 참조를 사용해서 연관된 객체를 찾는 것을 객체 그래프 탐색이라고 한다.
- 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다.
```java
  member.getOrder().getOrderItem(); //자유로운 객체 그래프 탐색
```
- 근데 SQL에서 연관 객체를 같이 조회하지 않으면 다른 객체 그래프는 데이터가 없으므로 탐색할 수 없다.
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.
- 비즈니스 로직에 따라 사용하는 객체 그래프가 달라 언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수 없다.
```java
class MemberService{
  ...
  public void process(){
    Member member = MerberDAO.find(memberId);
    member.getTeam();  //member -> team 객체 그래프 탐색이 가능한가? SQL 봐야알겠는데..
    member.getOrder(); //이것도 SQL 봐야겠는걸..
  }
}
```
- member 객체는 조회했지만 이 객체와 연관된 Team,Order 방향으로 객체 그래프를 탐색할 수 있을지 없을지는 예측할 수 없다.
- 데이터 접근 계층 DAOO를 열어서 SQL을 직접 확인해야한다.
- SQL에 논리적으로 종속되어 있으니 SQL을 직접 확인하지 않는이상 객체 그래프만 가지고 예측하고 확신할 수 없다.
  
#### JPA와 객체 그래프 탐색
- JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SOL을 실행한다.
- 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 자연 로딩이라 한다.
- JPA와 관련된 어떤 코드도 직접 사용하지 않는다. (JPA는 지연 로딩을 투명하게 처리함)
```java
    /*한 테이블씩 조회*/
    //처음 조회 시점에 MEMBER SQL 
    Member member = jpa.find(Member.class,memberId);

    Order order = member.getOrder();
    order.getOrderDate(); //ORDER를 사용하는 시점에 ORDER SQL
 ```
- 한 테이블씩 조회하는 것보다 Member을 조회하는 시점에 SQL 조인을 사용해서 Member와 Order를 함께 조회하는 것이 효과적이다.
- JPA는 연관된 객체를 즉시 함께 조회할지 아니면 실제 사용되는 시점에 지연해서 조회할지를 간단한 설정으로 정의할 수 있다.
- 즉시 함께 조회한다고 설정하면 JPA는 Member를 조회할 때 다음 Order도 JOIN해서 가져온다.

### 1.2.4 비교
- 데이터베이스는 기본키의 값으로 ROW를 구분하고 객체는 동일성비교와 동등성비교 방법으로 구분한다.
  * 동일성 비교는 == 비교로 객체 인스턴스의 주소값을 비교한다.
  * 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.
- 이러한 차이가 있어서 같은 SQL문을 태워 객체 2개를 생성하면 같은 데이터임에도 객체 측면에서 볼 때 두 객체는 다른 인스턴스다.
- 데이터베이스의 같은 ROW를 조회했지만 객체의 동일성 비교에는 실패한다.
- 이런 패러다임의 불일치 문제를 해결하기위해 데이터베이스의 같은 ROW를 조회할 때마다 같은 인스턴스를 반환하도록 구현하는건 쉽지않다.

#### JPA와 비교
- JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.
```java
    String memberId = "100"
    Member member1 = jpa.find(Member.class,memberId);
    Member member2 = jpa.find(Member.class,memberId);

    member1 == member2; //같다
 ```
- 객체 비교하는 것은 분산 환경이나 트랜잭션이 다른 상황까지 고려하면 더 복잡해진다.

### 1.2.5 정리
- 객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로다르다.
- 이러한 차이를 극보하려고 개발자가 많은 시간과 코드를 소비한다.
- 객체지향 애플리케이션은 정교한 객체 모델링을 할 수록 패러다임의 불일치 문제가 커진다.
- 데이터 중심 모델로 변할 수 밖에 없는 이유다.
- JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.
- 우리가 JPA를 공부해야하는 이유다.

### 1.3 JPA란 무엇인가?
- JPA(Java Persistence API)는 객체와 관계형 데이터베이스를 매핑하는 자바 진영의 ORM 기술 표준이다.
- 애플리케이션과 JDBC 사이에서 동작한다.
  (+그림첨부)
- ORM 프레임워크는 객체의 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.
- ORM 프레임워크를 사용하게 되면 SQL을 직접 작성하는 것이 아니라 객체를 마치 자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장하면된다.
- ORM 프레임워크가 적절한 SQL을 생성해서 데이터베이스에 객체를 저장해준다.
  (+그림첨부:저장)
  (+그림첨부:조회)
- ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 다양한 패러다임의 불일치 문제도 해결해준다.
- 따라서 객체 츨면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링하면 된다.
- 매핑 방법만 지정해서 ORM 프레임워크에 알려주면된다.

#### JPA 소게
-JPA는 자바 ORM 기술에 대한 API 표준 명세서다.
- Hibernate + EclipseLink + DataNucleus 인터페이스를 모아둔 것이다.
- JPA라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있는 장점이 있다.
  
### 1.3.2 왜 JPA를 사용해야하는가?
- 생산성
  * JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면된다.
    -> jpa.psersist(member); //저장
  * JPA는 SQL을 작성하고 JDBC API를 사용하는 지루하고 반복적인 일을 개발자 대신 처리한다.
  * 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도되고 DDL 문을 자동으로 생성해주기도 한다.
 
- 유지보수
  * SQL에 의존적인 개발은 엔티티에 필드를 하나만 추가해도 SQL과 결과 매핑을 하기 위한 JDBC API 코드를 모두 변경해야했다.
  * JPA를 사용하면 위 과정을 JPA가 대신 처리해주므로 수정해야 할 코드가 줄어든다.
  * 개발자가 작성해야 했던 SQL과 JDBC API 코드를 JPA가 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어든다.
  * JPA가 패러다임의 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점을 활용해서 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있다. 

- 패러다임의 불일치 해결
  * JPA는 상속,연관관계,객체 그래프 탐색 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.

- 성능
  * JPA는 애플리케이션과 데이터베이스 사이에서 동작하는데 이때 다양한 성능 최적화 기회를 제공한다.
  * 애플리케이션과 데이터베이스 사이의 계층이 하나 더 있으면 최적화 과나점에서 시도해볼 수 있는 것들이 많다.
    * 같은 트랜잭션 안에서 같은 회원을 두번 조회하는 코드의 일부다.
    * JDBC API를 사용해서 해당 코드를 직접 작성했다면 회원을 조회할 때마다 SELECT SQL을 사용해서 데이터베이스와 두번 통신했을거다.
    * JPA를 사용하면 회원을 조회하는 SQL은 한번만 데이터베이스를 전달하고 두번째는 조회한 회원 객체를 재사용한다.
    
  ```java
    String memberId = "helloId"
    Member member1 = jpa.find(memberId);
    Member member2 = jpa.find(memberId);
  ```

- 데이터 접근 추상화와 벤더 독립성
  * 관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다르다.
  * 애플리케이션은 처음 선택한 데이터베이스 기술에 종속되고 다른 데이터베이스로 변경하기는 매우 어렵다.
  * JPA는 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다.
  * JPA에 설정만 변경해서 알려주면 데이터베이스를 변경할 수 있다.
  (+ 그림 첨부)

### 1.4 정리
(생략)

### Q&A 
- ORM 프레임워크를 사용할 때 객체와 테이블 매핑을 올바르게 하려면 객체와 관계형 데이터베이스 양쪽을 모두 이해해야한다.
- JPA는 다양한 성능최적화 기능을 제공해서 잘 이해하고 사용하면 SQL을 직접사용할 때보다 더 좋은 성능을 낸다. 또한 JPA의 네이티브 SQL 기능을 사용해서 SQL을 직접 호출도 가능하다.
- 단, JPA를 이해하지 못하고 사용하면 N+1같은 문제로 인해 심각한 성능 저하가 발생한다.
  * N+1 문제는 한번의 쿼리로 가져와할 데이터를 N+1번의 추가적인 쿼리를 실행함으로써 발생하는 성능문제다.
  * 주로 관계형 데이터베이스에서 객체그래프를 로딩할 때 발생하는 문제다.
- JPA는 통계 쿼리 같이 복잡한 쿼리보다는 실시간 처리용 쿼리에 더 최적화되어있다.
- 복잡한 통계 쿼리는 SQL을 직접 작성하는 것이 더 쉬우며 JPA가 제공하는 네이티브 SQL을 사용하거나 마이바티스나 스프링의 JdbcTemplate 같은 SQL 매퍼 형태의 프레임워크를 혼용하는 것이 좋다.
- 마이바티스나 스프링 JdbcTemplate인 SQL 매퍼를 사용하면 SQL과 매핑할 객체만 지정하면 지루하게 반복되는 JDBC API 사용과 응답결과를 객체로 매핑하는 일을 대신 해주지만 SQL에 의존하는 개발은 피할 수 없다.
- ORM은 객체와 테이블을 매핑만 하면 ORM 프레임워크가 SQL을 만들어서 데이터베이스와 관련된 처리를 해주므로 SQL에 의존하는 개발을 피할 수 있다.
- JPA를 사용하려면 객체와 관계형 데이터베이스를 어떻게 매핑하는지 학습 후 JPA의 핵심 개념을 이해해야한다.
- 실무에서는 수많은 테이블과 객체를 매핑해야 하므로 매핑하는 방법을 정확히 이해해야한다.
- JPA의 핵심 개념인 영속성 컨텍스트에 대해 이해가 부족하면 SQL을 직접 사용해서 개발하는 것보다 못한 상황이 벌어진다.
- JPA가 어려운 근복적인 이유는 ORM이 객체지향과 관계형 데이터베이스라는 두 기둥 위에 있기 때문이다.
  
