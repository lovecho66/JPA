# 1장 JPA 소개

## 1.1 SQL을 직접 다룰 때 발생하는 문제점은 뭘까?

### 서론
- 자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.
- 데이터베이스에 데이터를 관리하려면 SQL을 사용해야 한다.
- JDBC API를 사용해서 SQL을 데이터베이스에 전달한다.

### 1.1.1 반복,반복,반복,반복 또 반복~♫
- 객체를 바로 DB에 넣고 조회할 수 있으면 좋겠지만 데이터베이스와 객체 구조는 너무 다르다.
- 그럼에도 우리는 객체를 DB에 넣어주기 위해 개발자가 SQL과 JDBC API를 사용해서 변환작업을 해줘야 한다.
- 어떠한 기능을 구현하더라도 변환작업 [SQL 작성, JDBC API 사용, 매핑]은 똑같이 작성해줘야한다.
- 데이터 접근 계층(DAO)에서 반복되는 변환작업을 지루하게 반복~ 반복~ 한다.

### 1.1.2 SQL에 의존적인 개발
- 필드를 추가해달라는 요구사항을 적용하려면 등록코드,수정코드,연관객체 작업할 때 SQL,JDBC API 수정해야하고
  조회코드는 매핑작업도 추가해서 확인해줘야 한다.
- 필드 하나 추가해달라는 요청사항으로 등록,수정,조회,연관 부분에서 하나씩 다 신경써주고 작업해야한다.
- 결국 SQL에 모든 것을 의존하는 상황에서는 엔티티를 신뢰하고 사용할 수 없다.
- 엔티티와 SQL은 아주 강한 의존관계를 가지고 있어 DAO에서 CRUD 코드와 SQL을 변경해야한다.
- 진정한 의미의 계층 분할도 아니고 엔티티를 신뢰할 수 없고 SQL에 의존적인 개발을 피하기 어렵다.
> 엔티티 : 비즈니스 요구사항을 모델링한 객체 (ex> Member, Team)

### 1.1.3 JPA와 문제 해결
- JPA를 사용하게 되면 객체를 데이터베이스에 저장하고 관리할 때 SQL을 작성할 필요가 없다.
- JPA가 제공하는 API를 사용하면 된다.
- JPA가 객체와 매핑정보를 보고 적절한 SQL 생성하고 데이터베이스에 전달한다.
- 조회같이 반환결과가 있다면 객체를 생성해서 반환한다.
- 수정같은 경우엔 별도 수정 메소드 없이 객체를 조회해서 값을 변경만 하면된다.
> 매핑정보는 어떤 객체를 어떤 테이블에 관리할지 정의한 정보

## 1.2 패러다임의 불일치 

### 서론
- 비즈니스 요구사항을 정의한 도메인 모델을 객체로 모델링하면 객체지향 언어가 가진 장점을 활용할 수 있다.
- 복잡한 애플리케이션은 대부분 객체지향 언어로 개발한다.
- 부모 객체를 상속받았거나 다른 객체를 참조하고 있다면 객체지향 언어로는 객체의 상태를 저장하기 쉽지 않다.
- 단순히 회원 객체만 저장하면 참조하는 팀 객체를 잃어버리는 경우가 생기는 것처럼 쉽지않다.
- 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고 직합적인 사고를 요구하기 때문에 객체를 저장시키기 알맞다.
- 그러나 관계형 데이터베이스에 바로 객체를 저장하기에 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다.
- 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.
- 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제를 해결하는데 너무 많은 시간과 코드를 소비하고 있다.

### 1.2.1 상속
- 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.
- 어떤 자식 테이블과 관계가 있는지 정의하는 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 가장 유사항 형태로 테이블 설계가 된다.
- 객체를 저장하게 되면 개발자가 직접 객체를 분해해서 두 SQL을 만들고 자식 타입에 따라서 슈퍼타입키도 변경해줘야한다.
  
#### JPA와 상속
- JPA를 사용하면 상속과 관련된 패러다임의 불일치를 해결하려고 소모하는 비용이 줄어든다.
- persist() 메소드를 사용하면 JPA가 INSERT SQL을 자동으로 생성해서 저장한다.
- find() 메소드를 사용하면 JPA가 연관된 테이블을 조인해서 조회한다.

## 1.2.2 연관관계
- 객체는 참조를 사용해서 다른 객체에 접근하여 연관된 객체를 조회한다.(객체는 참조가 있는 방향으로만 조회가능)
- 반면, 테이블은 외래키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.
- 참조를 사용하는 객체와 외래키를 사용하는 관계형 데이터베이스 사이의 패러다임 불일치의 문제가 크다.

### 객체를 테이블에 맞춰서 모델링
- 관계형 데이터베이스는 조인이라는 기능이 있으므로 외래키의 값을 그대로 보관해도 된다. 
- 객체는 연관된 객체의 참조를 보관해야 참조를 통해 연관된 객체를 찾을 수 있다.
- 외래키까지 관계형 데이터베이스가 사용하는 방식에 맞추면 참조를 통해서 조회할 수 없다.
- 좋은 객체 모델링은 기대하기 어렵고 결국 객체지향의 특징을 잃어버린다.

### 객체지향 모델링
- 객체는 참조를 통해서 관계를 맺는다.
- 객체의 필드를 보면 외래키의 값을 그대로 보관하는 것이 아니라 연관된 참조를 보관한다. (member.getTeam())
- 객체는 필드로 연관관계를 맺고 테이블은 외래키로 연관관계를 맺는다.
- 객체 모델은 외래키가 필요없고 참조만 있으면 되고테이블은 참조가 필요없고 외래키만 있으면 된다.
- 개발자가 중간에서 변환 역할을 해야한다.
- 저장하려면 외래키 값으로 변환해서 필드에 저장하고 조회시에 외래키 값을 객체의 참조로 변환해서 객체에 보관한다.

### JPA와 연관관계
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다.
- 개발자는 객체간의 관계만 설정하고 저장하면 JPA가 참조를 외래키로 변환해서 적절한 SQL문을 데이터베이스에 전달한다.
- 객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPA가 한다.

```java
Member member =jpa.find(Member.class,merberId); // 회원과 팀 연관관계 설정
Team team = member.getTeam();  //회원과 연관관계 함께 저장
```
