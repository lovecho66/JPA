# 1장 JPA 소개

## 1.1 SQL을 직접 다룰 때 발생하는 문제점은 뭘까?

### 서론
- 자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.
- 데이터베이스에 데이터를 관리하려면 SQL을 사용해야 한다.
- JDBC API를 사용해서 SQL을 데이터베이스에 전달한다.

### 1.1.1 반복,반복,반복,반복 또 반복~♫
- 객체를 바로 DB에 넣고 조회할 수 있으면 좋겠지만 데이터베이스와 객체 구조는 너무 다르다.
- 그럼에도 우리는 객체를 DB에 넣어주기 위해 개발자가 SQL과 JDBC API를 사용해서 변환작업을 해줘야 한다.
- 어떠한 기능을 구현하더라도 변환작업 [SQL 작성, JDBC API 사용, 매핑]은 똑같이 작성해줘야한다.
- 데이터 접근 계층(DAO)에서 반복되는 변환작업을 지루하게 반복~ 반복~ 한다.

### 1.1.2 SQL에 의존적인 개발
- 필드를 추가해달라는 요구사항을 적용하려면 등록코드,수정코드,연관객체 작업할 때 SQL,JDBC API 수정해야하고
  조회코드는 매핑작업도 추가해서 확인해줘야 한다.
- 필드 하나 추가해달라는 요청사항으로 등록,수정,조회,연관 부분에서 하나씩 다 신경써주고 작업해야한다.
- 결국 SQL에 모든 것을 의존하는 상황에서는 엔티티를 신뢰하고 사용할 수 없다.
- 엔티티와 SQL은 아주 강한 의존관계를 가지고 있어 DAO에서 CRUD 코드와 SQL을 변경해야한다.
- 진정한 의미의 계층 분할도 아니고 엔티티를 신뢰할 수 없고 SQL에 의존적인 개발을 피하기 어렵다.
> 엔티티 : 비즈니스 요구사항을 모델링한 객체 (ex> Member, Team)

### 1.1.3 JPA와 문제 해결
- JPA를 사용하게 되면 객체를 데이터베이스에 저장하고 관리할 때 SQL을 작성할 필요가 없다.
- JPA가 제공하는 API를 사용하면 된다.
- JPA가 객체와 매핑정보를 보고 적절한 SQL 생성하고 데이터베이스에 전달한다.
- 조회같이 반환결과가 있다면 객체를 생성해서 반환한다.
- 수정같은 경우엔 별도 수정 메소드 없이 객체를 조회해서 값을 변경만 하면된다.
> 매핑정보는 어떤 객체를 어떤 테이블에 관리할지 정의한 정보

## 1.2 패러다임의 불일치 

### 서론
- 비즈니스 요구사항을 정의한 도메인 모델을 객체로 모델링하면 객체지향 언어가 가진 장점을 활용할 수 있다.
- 복잡한 애플리케이션은 대부분 객체지향 언어로 개발한다.
- 부모 객체를 상속받았거나 다른 객체를 참조하고 있다면 객체지향 언어로는 객체의 상태를 저장하기 쉽지 않다.
- 단순히 회원 객체만 저장하면 참조하는 팀 객체를 잃어버리는 경우가 생기는 것처럼 쉽지않다.
- 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고 직합적인 사고를 요구하기 때문에 객체를 저장시키기 알맞다.
- 그러나 관계형 데이터베이스에 바로 객체를 저장하기에 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다르다.
- 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.
- 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제를 해결하는데 너무 많은 시간과 코드를 소비하고 있다.

### 1.2.1 상속
- 객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.
- 데이터베이스 모델링에서 이야기하는 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 가장 유사항 형태로 테이블 설계가 된다.
- 상속한 부모와 상속받은 자식은 DML이 각각 만들어지고 자식타입에 따라서 슈퍼타입 관계 데이터도 변경해줘야한다.
- JPA를 사용하면 상속과 관련된 패러다임의 불일치를 해결하려고 소모하는 비용이 줄어든다.
- persist() 메소드를 사용하면 JPA가 INSERT SQL을 자동으로 생성해서 저장한다.
- find() 메소드를 사용하면 JPA가 연관된 테이블을 조인해서 조회한다. 
