# 15장 고급 주제와 성능 최적화

## 예외처리
## 엔티티 비교
## 프록시 심화 주제

## 15.4 성능 최적화

### 15.4.1 N+1 문제

- JPA로 애플리케이션을 개발할 때 성능상 가장 주의해야 하는 것이 N+1 문제다.

#### 즉시 로딩과 N+1

![image.jpg1](./images/15.4_1.PNG)|![image.jpg1](./images/15.4_2.PNG)
|------|-----|

- 주문정보는 1:N，N：1 양방향 연관관계로 설정하고 회원이 참조하는 주문정보인 Member.orders를 즉시 로딩으로 설정했다.

![image.jpg1](./images/15.4_4.PNG)

- JPQL을 실행하면 JPA는 이것을 분석해서 SQL을 생성한다. 이때는 즉시 로딩과 지연 로딩에 대해서 전혀 신경 쓰지 않고 JPQL만 사용해서 SQL을 생성한다. 

```xml
SELECT * FROM MEMBER
``

- SQL의 실행 결과로 먼저 회원 엔티티를 애플리케이션에 로딩한다.
- 그런데 회원 엔티티와 연관된 주문 컬렉션이 즉시 로딩으로 설정되어 있으므로 JPA는 주문 컬렉션을 즉시 로딩하려고 다음 SQL을 추가로 실행한다.

```xml
SELECT * FROM ORDERS WHERE MEMBER_ID=?
``

- 조회된 회원이 하나면 이렇게 총 2번의 SQL을 실행된다.
- 조회된 회원이 5명이면 조회한 각각의 회원 엔티티와 연관된 주문 컬렉션을 즉시 조회하려고 총 5번의 SQL을 추가로 실행한다.
- 이처럼 처음 실행한 SQL의 결과 수만큼 추가로 SQL을 실행하는 것을 N+1 문제라 한다
- 핵심) 즉시 로딩은 JPQL을 실행할 때 N+1 문제가 발생할 수 있다.

#### 지연 로딩과 N+1

- 지연 로딩으로 변경해도 N+1 문제에서 자유로울 수는 없다.
- 즉, 지연로딩이든 즉시로딩이든 N+1 문제는 일어날 수 있다.

![image.jpg1](./images/15.4_4.PNG)
- 지연로딩으로 변경했다.
- 이렇게 지연 로딩으로 설정하면 JPQL에서는 N+l 문제가 발생하지 않는다.


```java
List<Member> members =
em.createQuery(Mselect m from Member m n, Member.class)
.getResultList();
``
- 지연 로딩이므로 데이터베이스에서 회원만 조회된다.

```xml
SELECT * FROM MEMBER
``
- 따라서 위 SQL만 실행되고 연관된 주문 컬렉션은 지연 로딩된다.

```java
firstMember = members.get(0) ;
firstMember.getOrders().size () ; //지연 로딩 초기화
```

- 이후 비즈니스 로직에서 주문 컬렉션을 실제 사용할 때 지연 로딩이 발생한다
- orders객체 가져옴
  
```xml
SELECT * FROM ORDERS WHERE MEMBER_ID=?
``

- members.get(0)로 회원 하나만 조회해서 사용했기 때문에 firstMember.getOrders().size () 를 호줄하면서 실행되는 SQL은 다음과 같다.

```java
for (Member member : members) {
  / / 지연 로딩 초기화
  System. out. println ("member ="+ member.getOrders().size());
}
```

- 문제는 다음처럼 모든 회원에 대해 연관된 주문 컬렉션을 사용할 때 발생한다
- 주문 컬렉션을 초기화하는 수만큼 다음 SQL이 실행될 수 있다. 회원이 5명이면 회원에 따른 주문도 5번 조회된다
- 이것도 결국 N+1 문제다.
  
* 지금까지 살펴본 것처럼 N+1 문제는 즉시 로딩과 지연 로딩일 때 모두 발생할 수 있다.
* 지금부터 N+1 문제를 피할 수 있는 다양한 방법을 알아보자.

🌟 N+1 헤결방법 찾자! 🌟

#### 1.페치 조인 사용

- N+1 문제를 해결하는 가장 일반적인 방법은 페치 조인을 사용하는 것이다.
- 페치조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회하므로 N+1 문제가 발생하지 않는다.

```xml
select m from Member m join fetch m.orders
```
```xml
SELECT M.*, 0.* FROM MEMBER M
INNER JOIN ORDERS O ON M.ID=O.MEMBER_ID
```
- 페치 조인을 사용하는 JPQL을 보자.
- TIP) 이 예제는 일대다 조인을 했으므로 결과가 늘어나서 중복된 결과가 나타날 수 있다. 따라서 JPQL의 DISTINCT를 사용해서 중복을 제거하는 것이 좋다,

#### 2.하이버네이트 @BatchSize

- 하이버네이트가 제공하는 org.hibernate.annotations.BatchSize 어노테이션을 사용하면 연관된 엔티티를 조회할 때 지정한 size만큼 SQL의 IN 절을 사용해서 조회한다.
- 만약 조회한 회원이 10명인데 size=5로 지정하면 2번의 SQL만 추가로 실행한다 (나눠서 한번에 사이즈만큼 실행)

```xml
SELECT * FROM ORDERS 
WHERE MEMBER_ID IN (
?,?,?,?,?
)
```

![image.jpg1](./images/15.4_6.PNG)

- 지연 로딩으로 설정하면 지연 로딩된 엔티티를 최초 사용하는 시점에 다음 SQL을 실행해서 5건의 데이터를 미리 로딩해둔다.
- 그리고 6번째 데이터를 사용하면 다음 SQL을 추가로 실행한다.

#### 3.하이버네이트 @Fetch(FetchMode. SUBSELECT)

![image.jpg1](./images/15.4_7.PNG)

-하이버네이트가 제공하는 org.hibernate .annotations.Fetch 어노테이션에 FetchMode를 SUBSELECT로 사용하면 
 연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N+1 문제를 해결한다.

![image.jpg1](./images/15.4_8.PNG) | ![image.jpg1](./images/15.4_9.PNG)
|-------|------|

- 즉시 로딩으로 설정하면 조회 시점에，지연 로딩으로 설정하면 지연 로딩된 엔티티를 사용하는 시점에 다음 SQL이 실행된다.
- 사용하는 시점에 조건에 맞는 관계 엔티티 조회한다. 

#### N+1 정리
- 즉시 로딩은 사용하지 말고 지연 로딩만 사용하는 걸 추천한다.
- 즉시 로딩 전략은 그럴듯해 보이지만 N+1 문제는 물론이고 비즈니스 로직에 따라 필요하지 않은 엔티티를 로딩해야 하는 상황이 자주 발생한다.
- 즉시 로딩의 가장 큰 문제는 성능 최적화가 어렵다는 점이다
- 중요!) 서 모두 지연 로딩으로 설정하고 성능 최적화가 꼭 필요한 곳에는 JPQL 페치 조인을 사용하자.

![image.jpg1](./images/15.4_10.PNG)

- 기본값이 즉시 로딩인 @OneToOne과 @ ManyToOne은 fetch= FetchType.LAZY로 설정해서 지연 로딩 전략을 사용하도록 변경하자.

### 15.4.2 읽기 전용 쿼리의 성능 최적화
- 엔티티가 영속성 컨텍스트에 관리되면 1차 캐시부터 변경 감지까지 얻을 수 있는 해택이 많다.
- 하지만 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다.
- 내용을 출력하는 단순한 조회 화면이 있다고 가정해보자. 그리고 조회한 엔티티를 다시 조회할 일도 없고 수정할 일도 없이 딱 한 번만 읽어서 화면에 출력하면 된다.
- 이때는 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화할 수 있다.

1.  스칼라 타입으로 조회
```xml
select o.id, o.name, ◦.price from Order p
```
- 엔티티가 아닌 스칼라 타입으로 모든 필드를 조회하는 것이다. 스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.
  
2.읽기전용 쿼리 힌트 사용  
```java
TypedQuery<Order> query = em. createQuery ("select o from Order o",Order.class);
query.setHintr’org.hibernate.readonly", true);
```
- 하이버네이트 전용 힌트인 〇 rg.hibernate.readonly를 사용하면 엔티티를 읽기 전용으로 조회할 수 있다.
- 읽기 전용이므로 영속성 컨텍스트는 스냅삿을 보관하지 않는다.
- 메모리 사용량을 최적화할 수 있다. 단 스냅샷이 없으므로 엔티티를 수정해도 데이터베이스에 반영되지 않는다.

3. 읽기전용트랜잭션 사용
```java
@Transactional(readonly = true)
```
- 스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있다.
- 트랜잭션에 readOnly=true 옵션을 주면 스프링 프레임워크가 하이버네 이트 세션의 플러시 모드를 MANUAL로 설정한다.
- 강제로 플러시를 호출하지 않는 한 플러시가 일어나지 않는다.
- 따라서 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시하지 않는다. 
- 트랜잭션을 시작했으므로 트랜잭션 시작，로직수행，트랜잭션 커밋의 과정은 이루어는진다. 단지 영속성 컨텍스트를 플러시하지 않을 뿐이다

4. 트랜잭션 밖에서 읽기
![image.jpg1](./images/15.4_11.PNG) | ![image.jpg1](./images/15.4_12.PNG)
|-------|------|
- 트랜잭션 밖에서 읽는다는 것은 트랜잭션 없이 엔티티를 조회한다는 뜻이다. 물론，쇼에서 데이터를 변경하려면 트랜잭션은 필수다.
- 트랜잭션을 사용하지 않으면 플러시가 일어나지 않으므로 조회 성능이 향상된다
- JPQL 쿼리도 트랜잭션 없이 실행하면 플러시를 호출하지 않는다.
- 스프링 프레임워크를 사용하면 읽기 전용 트랜잭션을 사용하는 것이 편리하다.

![image.jpg1](./images/15.4_13.PNG)
- 수백만 건의 데이터를 배치 처리를 일반적인 방식으로 엔티티를 계속 조회하면 영속성 컨텍스트에 아주 많은 엔티티가 쌓이면서 메모리 부족 오류가 발생한다.
- 읽기 전용 트랜잭션(또는 트랜잭션 밖에서 읽기)과 읽기 전용 쿼 리 힌트(또는 스칼라 타입으로 조회 )를 동시에 사용하는 것이 가장 효과적이다.

### 15.4.3 배치 처리

- 배치 처리는 적절한 단위로 영속성 컨텍스트를 초기화해야 한다. 또한，2차 캐시를 사용하고 있다면 2차 캐시에 엔티티를 보관하지 않도록 주의해야 한다.

#### JPA 등록 배치

![image.jpg1](./images/15.4_14.PNG)

- 엔티티를 100건 저장할 때마다 플러시를 호출하고 영속성 컨텍스트를 초기화한다. 지금까지 등록 배치 처리를 알아보았다.

#### JPA 수정 배치

- 배치 처리는 아주 많은 데이터를 조회해서 수정한다. 이때 수많은 데이터를 한번에 메모리에 올려둘 수 없어서 2가지 방법을 주로 사용한다.
- 페이징 처리와 커서 두가지 방법이 있다.

1. JPA 페이징 배치 처리

![image.jpg1](./images/15.4_15.PNG)

- 페이지 단위마다 영속성 컨텍스트를 플러시하고 초기화한다.
- JPA는 JDBC 커서cursor를 지원하지 않는다. 커서를 사용하려면 하이버네이트 세션을 사용해야한다. 

2. 하이버네이트 scroll 사용

![image.jpg1](./images/15.4_16.PNG)

- 하이버네이트는 scroll이라는 이름으로 JDBC 커서를 지원한다.

3. 하이버네이트 무상태 세션 사용

![image.jpg1](./images/15.4_17.PNG)

- 무상태 세션은 영속성 컨텍스트를 만들지 않고 심지어 2차 캐시도 사용하지 않는다.
- 무상태 세션은 영속성 컨텍스트가 없다.
- 그리고 엔티티를 수정하려면 무상태 세션이 제공하는 update () 메소드를 직접 호출해야 한다.

### 15.4.4  SQL 쿼리 힌트 사용

![image.jpg1](./images/15.4_18.PNG) | ![image.jpg1](./images/15.4_19.PNG)
|-------|------|

- SQL 힌트를 사용하려면 하이버네이트를 직접 사용해야 한다
- 참고로 여기서 말하는 SQL 힌트는 JPA 구현체에게 제공하는 힌트가 아니다.데이터베이스 벤더에게 제공하는 힌트다
- 현재 하이버네이트 4.3.10 버전은 오라클 방언에만 힌트가 적용되어 있다. 다른 데이터베이스에서 SQL 힌트를 사용하려면 각 방언에서 org.hibernate.

### 15.4.5  트랜잭션을 지원하는 쓰기 지연과 성능 최적화
- 트랜잭션을 지원하는 쓰기 지연을 활용해서 애플리케이션 성능을 최적화하는 방법을 알아보자

#### 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치
- 네트워크 호출 한 번은 단순한 메소드를 수만 번 호출하는 것보다 더 큰 비용이 든다.
- 히 비즈니스 로직이 복잡하게 얽혀 있는 곳에서 사용하기는 쉽지 않고 적용해도 코드가 상당히 지저분해진다.
- 그래서 보통은 수백 수천 건 이상의 데이터를 변경하는 특수한 상황에 SQL 배치 기능을 사용한다

![image.jpg1](./images/15.4_20.PNG)

- JPA는 플러시 기능이 있으므로 SQL 배치 기능을 효과적으로 사용할 수 있다

#### 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성
- 트랜잭션을 지원하는 쓰기 지연과 변경 감지 기능 덕분에 성능과 개발의 편의성을 가진다. 
- 제일 큰 장점은 데이터베이스 테이블 로우raw에 락 !。ck이 걸리는 시간을 최소화한다는 점이다

![image.jpg1](./images/15.4_21.PNG)

- JPA를 사용하지 않고 SQL을 직접 다루면 update (memberA) 를 호출할 때 UPDATE SQL을 실행하면서 데이터베이스 테이블 로우에 락을 건다.
- 이 락은 비즈니스로직 A(), 비즈니스로직 B() 를 모두 수행하고 commit() 을 호출할 때까지 유지된다.
- 트랜잭션 격리 수준에 따라 다르지만 보통 많이 사용하는 커밋된 읽기Read Committed 격리 수준이나 그 이상에서는 데이터베이스에 현재 수정 중인
- 데이터(로우)를 수정하려는 다른 트랜잭션은 락이 풀릴 때까지 대기한다.
- JPA는 커밋을 해야 플러시를 호출하고 데이터베이스에 수정 쿼리를 보낸다.
- commit () 을 호출할 때 UPDATE SQL을 실행하고 바로 데이터베이스 트랜잭션을 커밋한다.
- 쿼리를 보내고 바로 트랜잭션을 커밋하므로 결과적으로 데이터베이스에 락이 걸리는 시간을 최소화한다.
- 오히려 애플리케이션 서버를 증설해서 트랜잭션이 증가할수록 더 많은 데이터베이스 락이 걸린다. JPA의 쓰기 지연 기능은 데이터베이스에 락이 걸리는 시간을 최소화해서 동시에 더 많은 트랜잭션을 처리할 수 있는 장점이 있다.
